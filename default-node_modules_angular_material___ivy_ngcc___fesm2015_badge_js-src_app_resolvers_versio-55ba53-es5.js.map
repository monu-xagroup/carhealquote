{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAMA;AACA;AACA;AACA;AACA;AACA;AACA;;MAGA;MACA;MACA;MACA,oBAAsB;QAAA;UAAAA;QAAA;QAAA;MAAA,GACrB;MACD;MAAA,IACAC;QAAAC;QACA;UAAA;UAAAF;UACAG;UACAA;UACAA;UACAA;UACAA;UACAA;UACA;UACAA;UACAA;UACAA;UACA;AACA;AACA;AACA;UACAA;UACA;UACAA;UACA;UACAA;UACA;YACA;YACA;cACA;YACA;UACA;UAAA;QACA;QACA;QAAAC;UAAAC;UAAAC,KACA;YAAkB;UAAA;UAAAC,KAClB;YACA;YACA;UACA;UACA;QAAA;UAAAF;UAAAC,KACA;YAAoB;UAAA;UAAAC,KACpB;YACA,gBAAwB,8EAAqBC;UAC7C;UACA;QAAA;UAAAH;UAAAC,KACA;YAAwB;UAAA;UAAAC,KACxB;YACA;cACA;cACA;cACA;cACA;gBACAE,2EACAC;cACA;YACA;UACA;UACA;QAAA;UAAAL;UAAAC,KACA;YAAmB;UAAA;UAAAC,KACnB;YACA,eAAuB,8EAAqBC;UAC5C;UACA;QAAA;UAAAH;UAAAM,OACA;YACA;UACA;UACA;QAAA;UAAAN;UAAAM,OACA;YACA;UACA;QAAA;UAAAN;UAAAM,OACA;YACA;YACA;cACA;cACA,8CAAmDA,OAAMC;cACzD;YACA;UACA;QAAA;UAAAP;UAAAM,OACA;YACA;YACA;cACA;gBACA;cACA;cACA;cACA;cACA;gBACA;cACA;YACA;UACA;UACA;AACA;AACA;AACA;QAHA;UAAAN;UAAAM,OAIA;YACA;UACA;UACA;QAAA;UAAAN;UAAAM,OACA;YACA;cACA;YACA,OACA;cACA;YACA;YACA;UACA;UACA;QAAA;UAAAN;UAAAM,OACA;YACA;YACA;YACA;YACA;YACA;YACAD,4DAA6D,SAAS;YACtEA;YACAA;YACA;cACAA;YACA;YACA;cACAA;YACA;YACA;YACA;YACA;cACA;gBACAG;kBACAH;gBACA,CAAiB;cACjB,CAAa;YACb,OACA;cACAA;YACA;YACA;UACA;UAC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","names":["_classCallCheck","MatBadge","_inherits","_this","_createClass","key","get","set","val","newDescription","badgeElement","value","trim","requestAnimationFrame","classList","colorPalette","element","content","_MatBadgeBase","_angular_core__WEBPACK_IMPORTED_MODULE_2__","_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__","_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__","type","selectors","hostAttrs","hostVars","hostBindings","inputs","disabled","position","size","color","overlap","description","hidden","features","decorators","args","selector","host","MatBadgeModule","imports","_angular_material_core__WEBPACK_IMPORTED_MODULE_0__","exports","declarations","VersionControlResolver","commonService","showLoading","checkVersion","pipe","res","_this2","hideLoading","localVersion","localStorage","getItem","appVersion","buildRevision","setItem","setTimeout","location","reload","factory","providedIn"],"sources":["webpack:///node_modules/@angular/material/__ivy_ngcc__/fesm2015/badge.js","webpack:///src/app/resolvers/versionControl.resolver.ts"],"sourcesContent":["import { Directive, NgZone, ElementRef, Renderer2, Optional, Inject, Input, NgModule } from '@angular/core';\nimport { mixinDisabled, MatCommonModule } from '@angular/material/core';\nimport { AriaDescriber, A11yModule } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nlet nextId = 0;\n// Boilerplate for applying mixins to MatBadge.\n/** @docs-private */\nconst _MatBadgeBase = mixinDisabled(class {\n});\n/** Directive to display a text badge. */\nclass MatBadge extends _MatBadgeBase {\n    constructor(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {\n        super();\n        this._ngZone = _ngZone;\n        this._elementRef = _elementRef;\n        this._ariaDescriber = _ariaDescriber;\n        this._renderer = _renderer;\n        this._animationMode = _animationMode;\n        /** Whether the badge has any content. */\n        this._hasContent = false;\n        this._color = 'primary';\n        this._overlap = true;\n        /**\n         * Position the badge should reside.\n         * Accepts any combination of 'above'|'below' and 'before'|'after'\n         */\n        this.position = 'above after';\n        /** Size of the badge. Can be 'small', 'medium', or 'large'. */\n        this.size = 'medium';\n        /** Unique id for the badge */\n        this._id = nextId++;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const nativeElement = _elementRef.nativeElement;\n            if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {\n                throw Error('matBadge must be attached to an element node.');\n            }\n        }\n    }\n    /** The color of the badge. Can be `primary`, `accent`, or `warn`. */\n    get color() { return this._color; }\n    set color(value) {\n        this._setColor(value);\n        this._color = value;\n    }\n    /** Whether the badge should overlap its contents or not */\n    get overlap() { return this._overlap; }\n    set overlap(val) {\n        this._overlap = coerceBooleanProperty(val);\n    }\n    /** Message used to describe the decorated element via aria-describedby */\n    get description() { return this._description; }\n    set description(newDescription) {\n        if (newDescription !== this._description) {\n            const badgeElement = this._badgeElement;\n            this._updateHostAriaDescription(newDescription, this._description);\n            this._description = newDescription;\n            if (badgeElement) {\n                newDescription ? badgeElement.setAttribute('aria-label', newDescription) :\n                    badgeElement.removeAttribute('aria-label');\n            }\n        }\n    }\n    /** Whether the badge is hidden. */\n    get hidden() { return this._hidden; }\n    set hidden(val) {\n        this._hidden = coerceBooleanProperty(val);\n    }\n    /** Whether the badge is above the host or not */\n    isAbove() {\n        return this.position.indexOf('below') === -1;\n    }\n    /** Whether the badge is after the host or not */\n    isAfter() {\n        return this.position.indexOf('before') === -1;\n    }\n    ngOnChanges(changes) {\n        const contentChange = changes['content'];\n        if (contentChange) {\n            const value = contentChange.currentValue;\n            this._hasContent = value != null && `${value}`.trim().length > 0;\n            this._updateTextContent();\n        }\n    }\n    ngOnDestroy() {\n        const badgeElement = this._badgeElement;\n        if (badgeElement) {\n            if (this.description) {\n                this._ariaDescriber.removeDescription(badgeElement, this.description);\n            }\n            // When creating a badge through the Renderer, Angular will keep it in an index.\n            // We have to destroy it ourselves, otherwise it'll be retained in memory.\n            if (this._renderer.destroyNode) {\n                this._renderer.destroyNode(badgeElement);\n            }\n        }\n    }\n    /**\n     * Gets the element into which the badge's content is being rendered.\n     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).\n     */\n    getBadgeElement() {\n        return this._badgeElement;\n    }\n    /** Injects a span element into the DOM with the content. */\n    _updateTextContent() {\n        if (!this._badgeElement) {\n            this._badgeElement = this._createBadgeElement();\n        }\n        else {\n            this._badgeElement.textContent = this._stringifyContent();\n        }\n        return this._badgeElement;\n    }\n    /** Creates the badge element */\n    _createBadgeElement() {\n        const badgeElement = this._renderer.createElement('span');\n        const activeClass = 'mat-badge-active';\n        const contentClass = 'mat-badge-content';\n        // Clear any existing badges which may have persisted from a server-side render.\n        this._clearExistingBadges(contentClass);\n        badgeElement.setAttribute('id', `mat-badge-content-${this._id}`);\n        badgeElement.classList.add(contentClass);\n        badgeElement.textContent = this._stringifyContent();\n        if (this._animationMode === 'NoopAnimations') {\n            badgeElement.classList.add('_mat-animation-noopable');\n        }\n        if (this.description) {\n            badgeElement.setAttribute('aria-label', this.description);\n        }\n        this._elementRef.nativeElement.appendChild(badgeElement);\n        // animate in after insertion\n        if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => {\n                    badgeElement.classList.add(activeClass);\n                });\n            });\n        }\n        else {\n            badgeElement.classList.add(activeClass);\n        }\n        return badgeElement;\n    }\n    /** Sets the aria-label property on the element */\n    _updateHostAriaDescription(newDescription, oldDescription) {\n        // ensure content available before setting label\n        const content = this._updateTextContent();\n        if (oldDescription) {\n            this._ariaDescriber.removeDescription(content, oldDescription);\n        }\n        if (newDescription) {\n            this._ariaDescriber.describe(content, newDescription);\n        }\n    }\n    /** Adds css theme class given the color to the component host */\n    _setColor(colorPalette) {\n        if (colorPalette !== this._color) {\n            const classList = this._elementRef.nativeElement.classList;\n            if (this._color) {\n                classList.remove(`mat-badge-${this._color}`);\n            }\n            if (colorPalette) {\n                classList.add(`mat-badge-${colorPalette}`);\n            }\n        }\n    }\n    /** Clears any existing badges that might be left over from server-side rendering. */\n    _clearExistingBadges(cssClass) {\n        const element = this._elementRef.nativeElement;\n        let childCount = element.children.length;\n        // Use a reverse while, because we'll be removing elements from the list as we're iterating.\n        while (childCount--) {\n            const currentChild = element.children[childCount];\n            if (currentChild.classList.contains(cssClass)) {\n                element.removeChild(currentChild);\n            }\n        }\n    }\n    /** Gets the string representation of the badge content. */\n    _stringifyContent() {\n        // Convert null and undefined to an empty string which is consistent\n        // with how Angular handles them in inside template interpolations.\n        const content = this.content;\n        return content == null ? '' : `${content}`;\n    }\n}\nMatBadge.ɵfac = function MatBadge_Factory(t) { return new (t || MatBadge)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AriaDescriber), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };\nMatBadge.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatBadge, selectors: [[\"\", \"matBadge\", \"\"]], hostAttrs: [1, \"mat-badge\"], hostVars: 20, hostBindings: function MatBadge_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mat-badge-overlap\", ctx.overlap)(\"mat-badge-above\", ctx.isAbove())(\"mat-badge-below\", !ctx.isAbove())(\"mat-badge-before\", !ctx.isAfter())(\"mat-badge-after\", ctx.isAfter())(\"mat-badge-small\", ctx.size === \"small\")(\"mat-badge-medium\", ctx.size === \"medium\")(\"mat-badge-large\", ctx.size === \"large\")(\"mat-badge-hidden\", ctx.hidden || !ctx._hasContent)(\"mat-badge-disabled\", ctx.disabled);\n    } }, inputs: { disabled: [\"matBadgeDisabled\", \"disabled\"], position: [\"matBadgePosition\", \"position\"], size: [\"matBadgeSize\", \"size\"], color: [\"matBadgeColor\", \"color\"], overlap: [\"matBadgeOverlap\", \"overlap\"], description: [\"matBadgeDescription\", \"description\"], hidden: [\"matBadgeHidden\", \"hidden\"], content: [\"matBadge\", \"content\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\nMatBadge.ctorParameters = () => [\n    { type: NgZone },\n    { type: ElementRef },\n    { type: AriaDescriber },\n    { type: Renderer2 },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\n];\nMatBadge.propDecorators = {\n    color: [{ type: Input, args: ['matBadgeColor',] }],\n    overlap: [{ type: Input, args: ['matBadgeOverlap',] }],\n    position: [{ type: Input, args: ['matBadgePosition',] }],\n    content: [{ type: Input, args: ['matBadge',] }],\n    description: [{ type: Input, args: ['matBadgeDescription',] }],\n    size: [{ type: Input, args: ['matBadgeSize',] }],\n    hidden: [{ type: Input, args: ['matBadgeHidden',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBadge, [{\n        type: Directive,\n        args: [{\n                selector: '[matBadge]',\n                inputs: ['disabled: matBadgeDisabled'],\n                host: {\n                    'class': 'mat-badge',\n                    '[class.mat-badge-overlap]': 'overlap',\n                    '[class.mat-badge-above]': 'isAbove()',\n                    '[class.mat-badge-below]': '!isAbove()',\n                    '[class.mat-badge-before]': '!isAfter()',\n                    '[class.mat-badge-after]': 'isAfter()',\n                    '[class.mat-badge-small]': 'size === \"small\"',\n                    '[class.mat-badge-medium]': 'size === \"medium\"',\n                    '[class.mat-badge-large]': 'size === \"large\"',\n                    '[class.mat-badge-hidden]': 'hidden || !_hasContent',\n                    '[class.mat-badge-disabled]': 'disabled'\n                }\n            }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.AriaDescriber }, { type: ɵngcc0.Renderer2 }, { type: String, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [ANIMATION_MODULE_TYPE]\n            }] }]; }, { position: [{\n            type: Input,\n            args: ['matBadgePosition']\n        }], size: [{\n            type: Input,\n            args: ['matBadgeSize']\n        }], color: [{\n            type: Input,\n            args: ['matBadgeColor']\n        }], overlap: [{\n            type: Input,\n            args: ['matBadgeOverlap']\n        }], description: [{\n            type: Input,\n            args: ['matBadgeDescription']\n        }], hidden: [{\n            type: Input,\n            args: ['matBadgeHidden']\n        }], content: [{\n            type: Input,\n            args: ['matBadge']\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatBadgeModule {\n}\nMatBadgeModule.ɵfac = function MatBadgeModule_Factory(t) { return new (t || MatBadgeModule)(); };\nMatBadgeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatBadgeModule });\nMatBadgeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[\n            A11yModule,\n            MatCommonModule\n        ], MatCommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBadgeModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    A11yModule,\n                    MatCommonModule\n                ],\n                exports: [MatBadge, MatCommonModule],\n                declarations: [MatBadge]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatBadgeModule, { declarations: function () { return [MatBadge]; }, imports: function () { return [A11yModule,\n        MatCommonModule]; }, exports: function () { return [MatBadge, MatCommonModule]; } }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatBadge, MatBadgeModule };\n\n","import { Injectable } from '@angular/core';\nimport { Resolve } from '@angular/router';\n\nimport { catchError, map, Observable, of } from 'rxjs';\nimport { CommonService } from '../services/common/common.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class VersionControlResolver implements Resolve<Observable<any>> {\n  /**\n   * contructor\n   * @param commonService \n   */\n  constructor(private commonService: CommonService) { }\n  /**\n   * resolve the \n   * @returns \n   */\n  resolve(): Observable<any> {\n    this.commonService.showLoading();\n    return this.commonService.checkVersion().pipe(\n      map((res) => {\n        this.commonService.hideLoading();\n        const localVersion = localStorage.getItem('appVersion');\n        const appVersion = res.buildRevision;\n        if (localVersion && localVersion != appVersion) {\n          localStorage.setItem('appVersion', appVersion);\n          setTimeout(() => {\n            location.reload();\n          }, 10);\n          return of('new version available');\n        } else {\n          localStorage.setItem('appVersion', appVersion);\n          return of('new version is not available');\n        }\n      }),\n      catchError(() => {\n        this.commonService.hideLoading();\n        return of('data not available at this time');\n      })\n    )\n  }\n}"]}