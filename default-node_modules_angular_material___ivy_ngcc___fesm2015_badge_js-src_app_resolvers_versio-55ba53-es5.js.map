{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,sBACA;;AACA;;AACA,0BAAsB;AAAA;AAAA;AAAA;;AAAA;AAAA,UAAtB;AAEA;;;UACAA;;;;;AACA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AAzBA;AA0BA;AACA;;;;;eACA;AAAkB;AAAA;eAClB;AACA;;AACA;AACA;AACA;;;;eACA;AAAoB;AAAA;eACpB;AACA,4BAAwB,8EAAqBC,GAArB,CAAxB;AACA;AACA;;;;eACA;AAAwB;AAAA;eACxB;AACA;AACA;;AACA;;AACA;;AACA;AACAC,2FACAC,0CADA;AAEA;AACA;AACA;AACA;;;;eACA;AAAmB;AAAA;eACnB;AACA,2BAAuB,8EAAqBF,GAArB,CAAvB;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;;iBACA;AACA;;AACA;AACA;AACA,4DAAmDG,KAAnD,EAAyDC,IAAzD,GAAyDC,MAAzD,GAAyD,CAAzD;;AACA;AACA;AACA;;;iBACA;AACA;;AACA;AACA;AACA;AACA,eAHA,CAIA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;;;iBACA;AACA;AACA;AACA,aAFA,MAGA;AACA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;;AACA;AACA,mDAHA,CAIA;;AACA;;AACAH,wEAA6D,QAA7D;AACAA;AACAA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA,qEAfA,CAgBA;;;AACA;AACA;AACAI;AACAJ;AACiB,iBAFjB;AAGa,eAJb;AAKA,aANA,MAOA;AACAA;AACA;;AACA;AACA;AACA;;;;iBACA;AACA;AACA;;A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","names":["MatBadge","val","newDescription","badgeElement","value","trim","length","requestAnimationFrame","classList","colorPalette","element","content","_MatBadgeBase","_angular_core__WEBPACK_IMPORTED_MODULE_2__","_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__","_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__","type","selectors","hostAttrs","hostVars","hostBindings","ctx","inputs","disabled","position","size","color","overlap","description","hidden","features","decorators","args","selector","host","MatBadgeModule","imports","_angular_material_core__WEBPACK_IMPORTED_MODULE_0__","exports","declarations","VersionControlResolver","commonService","showLoading","checkVersion","pipe","res","hideLoading","localVersion","localStorage","getItem","appVersion","buildRevision","setItem","setTimeout","location","reload","_angular_core__WEBPACK_IMPORTED_MODULE_4__","factory","providedIn"],"sources":["webpack:///node_modules/@angular/material/__ivy_ngcc__/fesm2015/badge.js","webpack:///src/app/resolvers/versionControl.resolver.ts"],"sourcesContent":["import { Directive, NgZone, ElementRef, Renderer2, Optional, Inject, Input, NgModule } from '@angular/core';\nimport { mixinDisabled, MatCommonModule } from '@angular/material/core';\nimport { AriaDescriber, A11yModule } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/a11y';\nlet nextId = 0;\n// Boilerplate for applying mixins to MatBadge.\n/** @docs-private */\nconst _MatBadgeBase = mixinDisabled(class {\n});\n/** Directive to display a text badge. */\nclass MatBadge extends _MatBadgeBase {\n    constructor(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {\n        super();\n        this._ngZone = _ngZone;\n        this._elementRef = _elementRef;\n        this._ariaDescriber = _ariaDescriber;\n        this._renderer = _renderer;\n        this._animationMode = _animationMode;\n        /** Whether the badge has any content. */\n        this._hasContent = false;\n        this._color = 'primary';\n        this._overlap = true;\n        /**\n         * Position the badge should reside.\n         * Accepts any combination of 'above'|'below' and 'before'|'after'\n         */\n        this.position = 'above after';\n        /** Size of the badge. Can be 'small', 'medium', or 'large'. */\n        this.size = 'medium';\n        /** Unique id for the badge */\n        this._id = nextId++;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const nativeElement = _elementRef.nativeElement;\n            if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {\n                throw Error('matBadge must be attached to an element node.');\n            }\n        }\n    }\n    /** The color of the badge. Can be `primary`, `accent`, or `warn`. */\n    get color() { return this._color; }\n    set color(value) {\n        this._setColor(value);\n        this._color = value;\n    }\n    /** Whether the badge should overlap its contents or not */\n    get overlap() { return this._overlap; }\n    set overlap(val) {\n        this._overlap = coerceBooleanProperty(val);\n    }\n    /** Message used to describe the decorated element via aria-describedby */\n    get description() { return this._description; }\n    set description(newDescription) {\n        if (newDescription !== this._description) {\n            const badgeElement = this._badgeElement;\n            this._updateHostAriaDescription(newDescription, this._description);\n            this._description = newDescription;\n            if (badgeElement) {\n                newDescription ? badgeElement.setAttribute('aria-label', newDescription) :\n                    badgeElement.removeAttribute('aria-label');\n            }\n        }\n    }\n    /** Whether the badge is hidden. */\n    get hidden() { return this._hidden; }\n    set hidden(val) {\n        this._hidden = coerceBooleanProperty(val);\n    }\n    /** Whether the badge is above the host or not */\n    isAbove() {\n        return this.position.indexOf('below') === -1;\n    }\n    /** Whether the badge is after the host or not */\n    isAfter() {\n        return this.position.indexOf('before') === -1;\n    }\n    ngOnChanges(changes) {\n        const contentChange = changes['content'];\n        if (contentChange) {\n            const value = contentChange.currentValue;\n            this._hasContent = value != null && `${value}`.trim().length > 0;\n            this._updateTextContent();\n        }\n    }\n    ngOnDestroy() {\n        const badgeElement = this._badgeElement;\n        if (badgeElement) {\n            if (this.description) {\n                this._ariaDescriber.removeDescription(badgeElement, this.description);\n            }\n            // When creating a badge through the Renderer, Angular will keep it in an index.\n            // We have to destroy it ourselves, otherwise it'll be retained in memory.\n            if (this._renderer.destroyNode) {\n                this._renderer.destroyNode(badgeElement);\n            }\n        }\n    }\n    /**\n     * Gets the element into which the badge's content is being rendered.\n     * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).\n     */\n    getBadgeElement() {\n        return this._badgeElement;\n    }\n    /** Injects a span element into the DOM with the content. */\n    _updateTextContent() {\n        if (!this._badgeElement) {\n            this._badgeElement = this._createBadgeElement();\n        }\n        else {\n            this._badgeElement.textContent = this._stringifyContent();\n        }\n        return this._badgeElement;\n    }\n    /** Creates the badge element */\n    _createBadgeElement() {\n        const badgeElement = this._renderer.createElement('span');\n        const activeClass = 'mat-badge-active';\n        const contentClass = 'mat-badge-content';\n        // Clear any existing badges which may have persisted from a server-side render.\n        this._clearExistingBadges(contentClass);\n        badgeElement.setAttribute('id', `mat-badge-content-${this._id}`);\n        badgeElement.classList.add(contentClass);\n        badgeElement.textContent = this._stringifyContent();\n        if (this._animationMode === 'NoopAnimations') {\n            badgeElement.classList.add('_mat-animation-noopable');\n        }\n        if (this.description) {\n            badgeElement.setAttribute('aria-label', this.description);\n        }\n        this._elementRef.nativeElement.appendChild(badgeElement);\n        // animate in after insertion\n        if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => {\n                    badgeElement.classList.add(activeClass);\n                });\n            });\n        }\n        else {\n            badgeElement.classList.add(activeClass);\n        }\n        return badgeElement;\n    }\n    /** Sets the aria-label property on the element */\n    _updateHostAriaDescription(newDescription, oldDescription) {\n        // ensure content available before setting label\n        const content = this._updateTextContent();\n        if (oldDescription) {\n            this._ariaDescriber.removeDescription(content, oldDescription);\n        }\n        if (newDescription) {\n            this._ariaDescriber.describe(content, newDescription);\n        }\n    }\n    /** Adds css theme class given the color to the component host */\n    _setColor(colorPalette) {\n        if (colorPalette !== this._color) {\n            const classList = this._elementRef.nativeElement.classList;\n            if (this._color) {\n                classList.remove(`mat-badge-${this._color}`);\n            }\n            if (colorPalette) {\n                classList.add(`mat-badge-${colorPalette}`);\n            }\n        }\n    }\n    /** Clears any existing badges that might be left over from server-side rendering. */\n    _clearExistingBadges(cssClass) {\n        const element = this._elementRef.nativeElement;\n        let childCount = element.children.length;\n        // Use a reverse while, because we'll be removing elements from the list as we're iterating.\n        while (childCount--) {\n            const currentChild = element.children[childCount];\n            if (currentChild.classList.contains(cssClass)) {\n                element.removeChild(currentChild);\n            }\n        }\n    }\n    /** Gets the string representation of the badge content. */\n    _stringifyContent() {\n        // Convert null and undefined to an empty string which is consistent\n        // with how Angular handles them in inside template interpolations.\n        const content = this.content;\n        return content == null ? '' : `${content}`;\n    }\n}\nMatBadge.ɵfac = function MatBadge_Factory(t) { return new (t || MatBadge)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AriaDescriber), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };\nMatBadge.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatBadge, selectors: [[\"\", \"matBadge\", \"\"]], hostAttrs: [1, \"mat-badge\"], hostVars: 20, hostBindings: function MatBadge_HostBindings(rf, ctx) { if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mat-badge-overlap\", ctx.overlap)(\"mat-badge-above\", ctx.isAbove())(\"mat-badge-below\", !ctx.isAbove())(\"mat-badge-before\", !ctx.isAfter())(\"mat-badge-after\", ctx.isAfter())(\"mat-badge-small\", ctx.size === \"small\")(\"mat-badge-medium\", ctx.size === \"medium\")(\"mat-badge-large\", ctx.size === \"large\")(\"mat-badge-hidden\", ctx.hidden || !ctx._hasContent)(\"mat-badge-disabled\", ctx.disabled);\n    } }, inputs: { disabled: [\"matBadgeDisabled\", \"disabled\"], position: [\"matBadgePosition\", \"position\"], size: [\"matBadgeSize\", \"size\"], color: [\"matBadgeColor\", \"color\"], overlap: [\"matBadgeOverlap\", \"overlap\"], description: [\"matBadgeDescription\", \"description\"], hidden: [\"matBadgeHidden\", \"hidden\"], content: [\"matBadge\", \"content\"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });\nMatBadge.ctorParameters = () => [\n    { type: NgZone },\n    { type: ElementRef },\n    { type: AriaDescriber },\n    { type: Renderer2 },\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\n];\nMatBadge.propDecorators = {\n    color: [{ type: Input, args: ['matBadgeColor',] }],\n    overlap: [{ type: Input, args: ['matBadgeOverlap',] }],\n    position: [{ type: Input, args: ['matBadgePosition',] }],\n    content: [{ type: Input, args: ['matBadge',] }],\n    description: [{ type: Input, args: ['matBadgeDescription',] }],\n    size: [{ type: Input, args: ['matBadgeSize',] }],\n    hidden: [{ type: Input, args: ['matBadgeHidden',] }]\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBadge, [{\n        type: Directive,\n        args: [{\n                selector: '[matBadge]',\n                inputs: ['disabled: matBadgeDisabled'],\n                host: {\n                    'class': 'mat-badge',\n                    '[class.mat-badge-overlap]': 'overlap',\n                    '[class.mat-badge-above]': 'isAbove()',\n                    '[class.mat-badge-below]': '!isAbove()',\n                    '[class.mat-badge-before]': '!isAfter()',\n                    '[class.mat-badge-after]': 'isAfter()',\n                    '[class.mat-badge-small]': 'size === \"small\"',\n                    '[class.mat-badge-medium]': 'size === \"medium\"',\n                    '[class.mat-badge-large]': 'size === \"large\"',\n                    '[class.mat-badge-hidden]': 'hidden || !_hasContent',\n                    '[class.mat-badge-disabled]': 'disabled'\n                }\n            }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.AriaDescriber }, { type: ɵngcc0.Renderer2 }, { type: String, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [ANIMATION_MODULE_TYPE]\n            }] }]; }, { position: [{\n            type: Input,\n            args: ['matBadgePosition']\n        }], size: [{\n            type: Input,\n            args: ['matBadgeSize']\n        }], color: [{\n            type: Input,\n            args: ['matBadgeColor']\n        }], overlap: [{\n            type: Input,\n            args: ['matBadgeOverlap']\n        }], description: [{\n            type: Input,\n            args: ['matBadgeDescription']\n        }], hidden: [{\n            type: Input,\n            args: ['matBadgeHidden']\n        }], content: [{\n            type: Input,\n            args: ['matBadge']\n        }] }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatBadgeModule {\n}\nMatBadgeModule.ɵfac = function MatBadgeModule_Factory(t) { return new (t || MatBadgeModule)(); };\nMatBadgeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatBadgeModule });\nMatBadgeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[\n            A11yModule,\n            MatCommonModule\n        ], MatCommonModule] });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatBadgeModule, [{\n        type: NgModule,\n        args: [{\n                imports: [\n                    A11yModule,\n                    MatCommonModule\n                ],\n                exports: [MatBadge, MatCommonModule],\n                declarations: [MatBadge]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatBadgeModule, { declarations: function () { return [MatBadge]; }, imports: function () { return [A11yModule,\n        MatCommonModule]; }, exports: function () { return [MatBadge, MatCommonModule]; } }); })();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatBadge, MatBadgeModule };\n\n","import { Injectable } from '@angular/core';\r\nimport { Resolve } from '@angular/router';\r\n\r\nimport { catchError, map, Observable, of } from 'rxjs';\r\nimport { CommonService } from '../services/common/common.service';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class VersionControlResolver implements Resolve<Observable<any>> {\r\n  /**\r\n   * contructor\r\n   * @param commonService \r\n   */\r\n  constructor(private commonService: CommonService) { }\r\n  /**\r\n   * resolve the \r\n   * @returns \r\n   */\r\n  resolve(): Observable<any> {\r\n    this.commonService.showLoading();\r\n    return this.commonService.checkVersion().pipe(\r\n      map((res) => {\r\n        this.commonService.hideLoading();\r\n        const localVersion = localStorage.getItem('appVersion');\r\n        const appVersion = res.buildRevision;\r\n        if (localVersion && localVersion != appVersion) {\r\n          localStorage.setItem('appVersion', appVersion);\r\n          setTimeout(() => {\r\n            location.reload();\r\n          }, 10);\r\n          return of('new version available');\r\n        } else {\r\n          localStorage.setItem('appVersion', appVersion);\r\n          return of('new version is not available');\r\n        }\r\n      }),\r\n      catchError(() => {\r\n        this.commonService.hideLoading();\r\n        return of('data not available at this time');\r\n      })\r\n    )\r\n  }\r\n}"]}